[![GitHub issues](https://img.shields.io/github/issues/covrom/gonec.svg)](https://github.com/covrom/gonec/issues) [![Travis](https://travis-ci.org/covrom/gonec.svg?branch=master)](https://github.com/covrom/gonec/releases)

[![Gonec Logo](/extra/gonec.png)](https://github.com/covrom/gonec/releases)

[![Download](/extra/button_down.png)](https://github.com/covrom/gonec/releases)
[![Docs](/extra/button_doc.png)](https://github.com/covrom/gonec/wiki)
[![Demo site](/extra/button_play.png)](https://gonec.herokuapp.com/)
[![Chat](/extra/button_chat.png)](https://gitter.im/gonec/Lobby)

## Цели

Интерпретатор создан для решения программистами 1С множества задач, связанных с высокопроизводительными распределенными вычислениями, создания вэб-сервисов и вэб-порталов для работы тысяч пользователей, работы с высокоэффективными базами данных с использованием синтаксиса языка, похожего, но не ограниченного возможностями языка 1С.

Включив такой интерпретатор в свое решение, Вы можете предоставить высокий уровень сервиса для своих клиентов, который обгонит решения не только ваших конкурентов на рынке 1С, но и конкурентных платформ в enterprise.

Интерпретатор разрабатывается “от простого к сложному”. На начальных этапах будет включена базовая функциональность многопоточных вычислений и сетевых сервисов. В перспективе планируется организация работы с различными базами данных и визуализация управляемых форм, созданных в конфигураторе.

Еще никогда не были так просто доступны программистам 1С возможности:
* Создать микросервис с произвольным сетевым протоколом, развернуть его на linux, в docker контейнере или кластере kubernetes
* Выполнить сложную многопоточную вычислительную задачу для десятков тысяч подключающихся пользователей за миллисекунды
* Взаимодействовать с пользователем через web-браузер с минимальным трафиком
* Сохранять и получать данные с максимально доступной скоростью в key-value базах данных

## Описание синтаксиса языка и примеры использования интерпретатора

[Документация находится здесь](https://github.com/covrom/gonec/wiki)

## Почему синтаксис похож на 1С?

Синтаксис 1С знаком и удобен сотням тысяч программистов в России и СНГ, а в перспективе и зарубежом. Это позволяет создавать решения, которые могут поддерживаться любыми программистами 1С, и которые не будут требовать дополнительной квалификации.

## Какие основные отличия от языка 1С?
Язык интерпретатора поддерживает синтаксис языка 1С, но дополнительно к этому имеет возможности, унаследованные от синтаксиса языка Go (Golang) и Javascript:
* Многопоточное программирование: создание и работа с параллельно выполняемыми функциями и каналами передачи информации между ними (полный аналог chan и go из языка Го)
* Поддержка срезов массивов и строк, как в языке Python (высокоскоростная реализация на слайсах Go)
* Поддержка множества возвращаемых значений из функций и множественного присваивания между переменными (а,б=б,а) как в языке Go
* Возможность указания структурных литералов и содержимого массивов прямо в исходном коде (как в Go)
* Передача функций как параметров (функциональное программирование)

## Архитектура языка и платформы

Архитектура платформы
![System architecture](/extra/architecture.png)

Архитектура языка Гонец
![Language architecture](/extra/langarch.png)

## Масштабируемость языка и платформы
Язык Гонец расширяется путем изменения правил синтаксиса в формате YACC, а так же написания собственных высокоэффективных библиотек структур и функций на Го, которые могут быть доступны как объекты метаданных в языке Гонец.

В системных библиотеках языка могут создаваться объекты метаданных, при импорте соответствующей библиотеки. Данные объекты метаданных являются функциональными структурными типами, функциональность которых скомпилирована на языке Го. Объекты таких метаданных имеют встроенные методы для работы с ними. Добавление нового типа с новой функциональностью не представляет никакой сложности для программистов на Го. Компиляция усовершенствованной версии интерпретатора выполняется одной командой `go build .` в папке с исходными текстами, и занимает всего несколько секунд.

Интерпретатор может и запускать микросервисы, и сам выступать в роли такого микросервиса.

Посмотреть на использование интерпретатора в роли микросервиса можно по [ссылке](https://gonec.herokuapp.com/) выше.
В этой реализации в интерпретатор встроена простая система запуска кода через обычный браузер, которая работает на технологии ajax, общающаяся с микросервисом сессий исполнения кода интерпретатором.

## Каковы отличия в метаданных и среде исполнения?
На первом этапе разработки планируется:
* поддержка стандартной библиотеки Go в части создания вэб-сервисов с html-шаблонами
* поддержка и работа с postgresql, включая hstore
* мултиплатформенность: выполнение кода на любой платформе (Windows, Linux, MacOs)
* выполнение в легковесных ОС alpinelinux
* запуск на встраиваемых устройствах с низким энергопотреблением класса "умный дом"/"интернет вещей" (например, Raspberry Pi)
* запуск в контейнерах docker

## Какова производительность интерпретатора?
Производительность ожидается выше, чем у интерпретатора языка Python при работе с большими данными и сетевыми соединениями.
Скорость интерпретации кода соответствует скорости программ на Go и скорости работы библиотек, написанных на Go.
Основные преимущества языка Го (golang), которые позволят создавать производительные решения на языке Гонец:
* Кроссплатформенная компиляция - исполнение на любых устройствах
* Возможно создание функций на ассемблере и на C - для взаимодействия со специфичными драйверами устройств, например
* Встроенная очень хорошо продуманная система горутин и каналов для обеспечения параллельной обработки информации
* Отлично оптимизированный SSA-компилятор в версии Go 1.9
* Быстрый и оптимизированный сборщик мусора - во время работы программ память используется минимально
* Переиспользуется ранее выделенная память - существенное ускорение за счет отсутствия лишних malloc
* Мапы хэшированы по ключам, слайсы работают очень быстро
* Оптимизирован для создания нагруженных сервисов: возможна реализация как обработки больших объемов данных, так и обработки часто поступающих запросов

Пример сравнения производительности цикла без тела, перебор значений от 1 до 1 млн.
Участники сравнения:
* Гонец с регистровой виртуальной машиной
* 1С:Предприятие 8.3.9.2170 (файловая)

![PerfVs1C](/extra/perf1c.gif)

## Какая технологическая основа используется в интерпретаторе?
Интерптетатор реализован на языке Go путем адаптации исходных кодов интерпретатора языка anko (https://github.com/mattn/anko).
Интерпретатор использует собственную регистровую виртуальную машину, также написанную на языке Go, а значит, имеет отличную производительность и стабильность.
Исходный код на языке Гонец преобразуется в специальный байткод, который исполняется максимально быстро с минимальной нагрузкой на garbage collector. Используется оптимизация "свертка констант".
Пример преобразования в байткод:
```
а = [](0,1000*1000)
для н=1 по 10*10*10000 цикл
  а=а+[н]+[н*10] //постоянно выделяется память для объединения массивов
конеццикла
к=0
для каждого н из а цикл
  к=к+н
конеццикла
сообщить(к)
а=Новый("__функциональнаяструктуратест__")
а.ПолеСтрока = "авузлхвсзщл"
а.ПолеСтрока = "АВ"+а.ПолеСтрока[2:]
сообщить(а.ВСтроку(), а.ПолеСтрока+":ok")
```
Скомпилированный код для виртуальной машины:
```
LOAD r0, 0
LOAD r1, 1000000
MAKEARR r0, LEN r0, CAP r1
SET "а", r0
LOAD r1, 1
LOAD r2, 1000000
FORNUM r0, FROM r1, TO r2, BREAK TO L1
L2:
NEXTNUM r0, ENDLOOP L1
SET "н", r0
GET r3, "а"
MAKESLICE r4, LEN 1, CAP 1
GET r5, "н"
SETIDX r4[0], r5
OP r3, "+", r4
MAKESLICE r4, LEN 1, CAP 1
GET r5, "н"
LOAD r6, 10
OP r5, "*", r6
SETIDX r4[0], r5
OP r3, "+", r4
SET "а", r3
JMP L2
L1:
POPFOR L2
LOAD r0, 0
SET "к", r0
GET r0, "а"
FOREACH r0, ITER r1, BREAK TO L3
L4:
NEXT r2, FROM r0, ITER r1, ENDLOOP L3
SET "н", r2
GET r3, "к"
GET r4, "н"
OP r3, "+", r4
SET "к", r3
JMP L4
L3:
POPFOR L4
GET r0, "к"
CALL "сообщить", ARGS r0, ARGS_COUNT 1, VARARG false, GO false, RETURN r0
LOAD r0, "__функциональнаяструктуратест__"
SETNAME r0
MAKE r0 AS TYPE r0
SET "а", r0
LOAD r0, "авузлхвсзщл"
GET r1, "а"
SETMEMBER r1."ПолеСтрока", r0
LOAD r0, "АВ"
GET r1, "а"
GETMEMBER r1, "ПолеСтрока"
LOAD r2, 2
LOAD r3, <nil>
SLICE r1[r2 : r3]
OP r0, "+", r1
GET r1, "а"
SETMEMBER r1."ПолеСтрока", r0
GET r0, "а"
GETMEMBER r0, "ВСтроку"
CALL REG r0, ARGS r1, ARGS_COUNT 0, VARARG false, GO false, RETURN r0
GET r1, "а"
GETMEMBER r1, "ПолеСтрока"
LOAD r2, ":ok"
OP r1, "+", r2
CALL "сообщить", ARGS r0, ARGS_COUNT 2, VARARG false, GO false, RETURN r0
```
Результат исполнения:
```
5500005500000
ПолеЦелоеЧисло=0, ПолеСтрока=АВузлхвсзщл АВузлхвсзщл:ok
Время компиляции: 0s
Время исполнения: 1.7867144s
```

## Какой статус разработки интерпретатора?
Интерпретатор работает стабильно, протестирован и находится в стадии разработки стандартной библиотеки.
